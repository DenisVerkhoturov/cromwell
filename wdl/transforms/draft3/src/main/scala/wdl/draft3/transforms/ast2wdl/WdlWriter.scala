package wdl.draft3.transforms.ast2wdl

import simulacrum.typeclass
import wdl.model.draft3.elements.CommandPartElement.{PlaceholderCommandPartElement, StringCommandPartElement}
import wdl.model.draft3.elements.ExpressionElement._
import wdl.model.draft3.elements._
import wom.types._
import wom.values.{WomBoolean, WomEnumerationValue, WomFile, WomFloat, WomInteger, WomLong, WomString}

import scala.language.implicitConversions

@typeclass
trait WdlWriter[A] {
  def toWdl(a: A): String
}

object WdlWriter {

  // Auto-generated by simulacrum
  import WdlWriter.ops._

  implicit val ifWriter: WdlWriter[IfElement] = new WdlWriter[IfElement] {
    def toWdl(a: IfElement) = {
      s"""if (${a.conditionExpression.toWdl}) {
         |  ${a.graphElements.map(_.toWdl).mkString("\n")}
         |}
       """.stripMargin
    }
  }

  implicit val expressionWriter: WdlWriter[ExpressionElement] = new WdlWriter[ExpressionElement] {
    def toWdl(a: ExpressionElement) = a match {
      case a: PrimitiveLiteralExpressionElement => a.toWdl
      case _: StringExpression => ???
      case a: StringLiteral => a.value
      case _: ObjectLiteral => ???
      case _: ArrayLiteral => ???
      case _: MapLiteral => ???
      case _: PairLiteral => ???
      case _: UnaryOperation => ???
      case a: BinaryOperation => a.toWdl
      case _: TernaryIf => ???
      case a: FunctionCallElement => a.toWdl
      case a: IdentifierLookup => a.identifier
      case a: IdentifierMemberAccess => a.toWdl
      case _: ExpressionMemberAccess => ???
      case _: IndexAccess => ???
    }
  }

  implicit val identifierMemberAccessWriter: WdlWriter[IdentifierMemberAccess] = new WdlWriter[IdentifierMemberAccess] {
    def toWdl(a: IdentifierMemberAccess): String = {
      s"${a.first}.${a.second}" + (if (a.memberAccessTail.nonEmpty) {
        a.memberAccessTail.mkString(".")
      } else {
        ""
      })
    }
  }

  implicit val binaryOperationWriter: WdlWriter[BinaryOperation] = new WdlWriter[BinaryOperation] {
    def toWdl(a: BinaryOperation) = {
      def sandwich(opString: String) = s"${a.left.toWdl} $opString ${a.right.toWdl}"

      a match {
        case _: LogicalOr           => sandwich("||")
        case _: LogicalAnd          => sandwich("&&")
        case _: Equals              => sandwich("==")
        case _: NotEquals           => sandwich("!=")
        case _: LessThan            => sandwich("< ")
        case _: LessThanOrEquals    => sandwich("<=")
        case _: GreaterThan         => sandwich("> ")
        case _: GreaterThanOrEquals => sandwich(">=")
        case _: Add                 => sandwich("+")
        case _: Subtract            => sandwich("-")
        case _: Multiply            => sandwich("*")
        case _: Divide              => sandwich("/")
        case _: Remainder           => sandwich("%")
      }
    }
  }

  implicit val graphElementWriter: WdlWriter[WorkflowGraphElement] = new WdlWriter[WorkflowGraphElement] {
    def toWdl(a: WorkflowGraphElement) = a match {
      case a: CallElement => a.toWdl
      case a: IntermediateValueDeclarationElement => a.toWdl
      case _: OutputDeclarationElement => ???
      case a: InputDeclarationElement => a.toWdl
      case a: IfElement => a.toWdl
      case _: ScatterElement => ???
    }
  }

  implicit val callBodyElement: WdlWriter[CallBodyElement] = new WdlWriter[CallBodyElement] {
    def toWdl(a: CallBodyElement): String = {
      if (a.inputs.nonEmpty) {
        s"""input:
           |  ${a.inputs.map(_.toWdl).mkString(",\n")}
         """.stripMargin
      } else {
        ""
      }
    }
  }

  implicit val callElementWriter: WdlWriter[CallElement] = new WdlWriter[CallElement] {
    def toWdl(a: CallElement) = {
      val aliasExpression = a.alias match {
        case Some(alias) => s" as $alias"
        case None => ""
      }

      val bodyExpression = a.body match {
        case Some(body) => body.toWdl
        case None => ""
      }

      s"""call ${a.callableName}$aliasExpression {
         |  $bodyExpression
         |}
       """.stripMargin
    }
  }

  implicit val intermediateValueDeclarationElement: WdlWriter[IntermediateValueDeclarationElement] = new WdlWriter[IntermediateValueDeclarationElement] {
    def toWdl(a: IntermediateValueDeclarationElement) =
      s"${a.typeElement.toWdl} ${a.name} = ${a.expression.toWdl}"
  }

  implicit val typeElementWriter: WdlWriter[TypeElement] = new WdlWriter[TypeElement] {
    def toWdl(a: TypeElement) = a match {
      case a: PrimitiveTypeElement => a.primitiveType.toWdl
      case _: ArrayTypeElement => ???
      case _: MapTypeElement => ???
      case _: OptionalTypeElement => ???
      case _: NonEmptyTypeElement => ???
      case _: PairTypeElement => ???
      case _: ObjectTypeElement.type => ???
      case _: TypeAliasElement => ???
    }
  }

  implicit val primitiveTypeElementWriter: WdlWriter[WomPrimitiveType] = new WdlWriter[WomPrimitiveType] {
    def toWdl(a: WomPrimitiveType) = a.toDisplayString
  }

  implicit val workflowDefinitionElementWriter: WdlWriter[WorkflowDefinitionElement] = new WdlWriter[WorkflowDefinitionElement] {
    def toWdl(a: WorkflowDefinitionElement) = {
      val inputs = a.inputsSection match {
        case Some(i) => i.toWdl
        case None => ""
      }
      val outputs = a.outputsSection match {
        case Some(o) => o.toWdl
        case None => ""
      }

      s"""workflow ${a.name} {
         |  $inputs
         |  ${a.graphElements.map(_.toWdl).mkString("\n")}
         |  $outputs
         |}
       """.stripMargin
    }
  }

  implicit val taskDefinitionTypeElementWriter: WdlWriter[TaskDefinitionElement] = new WdlWriter[TaskDefinitionElement] {
    def toWdl(a: TaskDefinitionElement) = {
//      a.inputsSection X
//      a.declarations X
//      a.outputsSection X
//      a.commandSection
//      a.runtimeSection
//      a.metaSection
//      a.parameterMetaSection
      val inputs = a.inputsSection match {
        case Some(i) => i.toWdl
        case None => ""
      }
      val outputs = a.outputsSection match {
        case Some(o) => o.toWdl
        case None => ""
      }

      s"""task ${a.name} {
         |  $inputs
         |  ${a.declarations.map(_.toWdl).mkString("\n")}
         |  $outputs
         |  ${a.commandSection.toWdl}
         |}
       """.stripMargin
    }
  }

  implicit val commandSectionElementWriter: WdlWriter[CommandSectionElement] = new WdlWriter[CommandSectionElement] {
    def toWdl(a: CommandSectionElement): String = {
      s"""command {
         |  ${a.parts.map(_.toWdl).mkString("\n")}
         |}
       """.stripMargin
    }
  }

  implicit val commandSectionLineWriter: WdlWriter[CommandSectionLine] = new WdlWriter[CommandSectionLine] {
    def toWdl(a: CommandSectionLine): String = {
      a.parts.map(_.toWdl).mkString(" ")
    }
  }

  implicit val commandPartElementWriter: WdlWriter[CommandPartElement] = new WdlWriter[CommandPartElement] {
    def toWdl(a: CommandPartElement): String = a match {
      case a: StringCommandPartElement => a.value
      case a: PlaceholderCommandPartElement =>
        s"$${${a.expressionElement.toWdl}}" // TODO: attributes
    }
  }

  implicit val inputsSectionElementWriter: WdlWriter[InputsSectionElement] = new WdlWriter[InputsSectionElement] {
    def toWdl(a: InputsSectionElement): String = {
      s"""input {
         |  ${a.inputDeclarations.map(_.toWdl).mkString("\n")}
         |}
       """.stripMargin
    }
  }

  implicit val inputDeclarationElementWriter: WdlWriter[InputDeclarationElement] = new WdlWriter[InputDeclarationElement] {
    def toWdl(a: InputDeclarationElement): String = {
      val expression = a.expression match {
        case Some(expr) => s" = ${expr.toWdl}"
        case None => ""
      }

      s"${a.typeElement.toWdl} ${a.name}$expression"
    }
  }

  implicit val outputsSectionElementWriter: WdlWriter[OutputsSectionElement] = new WdlWriter[OutputsSectionElement] {
    def toWdl(a: OutputsSectionElement): String = {
      s"""output {
         |  ${a.outputs.map(_.toWdl).mkString("\n")}
         |}
       """.stripMargin
    }
  }

  implicit val outputDeclarationElementWriter: WdlWriter[OutputDeclarationElement] = new WdlWriter[OutputDeclarationElement] {
    def toWdl(a: OutputDeclarationElement): String = {
      s"${a.typeElement.toWdl} ${a.name} = ${a.expression.toWdl}"
    }
  }

  implicit val functionCallElementWriter: WdlWriter[FunctionCallElement] = new WdlWriter[FunctionCallElement] {
    def toWdl(a: FunctionCallElement): String = a match {
      case _: StdoutElement.type => "stdout()"
      case _: StderrElement.type => "stderr()"
      case a: OneParamFunctionCallElement => a.toWdl
      case a: OneOrTwoParamFunctionCallElement => a.toWdl
      case a: TwoParamFunctionCallElement => a.toWdl
      case _: Sub => ???
    }
  }

  implicit val oneParamFunctionCallElementWriter: WdlWriter[OneParamFunctionCallElement] = new WdlWriter[OneParamFunctionCallElement] {
    def toWdl(a: OneParamFunctionCallElement): String = {
      def functionCall(name: String) = s"$name(${a.param.toWdl})"

      a match {
        case _: ReadLines =>    functionCall("read_lines")
        case _: ReadTsv =>      functionCall("read_tsv")
        case _: ReadMap =>      functionCall("read_map")
        case _: ReadObject =>   functionCall("read_object")
        case _: ReadObjects =>  functionCall("read_objects")
        case _: ReadJson =>     functionCall("read_json")
        case _: ReadInt =>      functionCall("read_int")
        case _: ReadString =>   functionCall("read_string")
        case _: ReadFloat =>    functionCall("read_float")
        case _: ReadBoolean =>  functionCall("read_boolean")
        case _: WriteLines =>   functionCall("write_lines")
        case _: WriteTsv =>     functionCall("write_tsv")
        case _: WriteMap =>     functionCall("write_map")
        case _: WriteObject =>  functionCall("write_object")
        case _: WriteObjects => functionCall("write_objects")
        case _: WriteJson =>    functionCall("write_json")
        case _: Range =>        functionCall("range")
        case _: Transpose =>    functionCall("transpose")
        case _: Length =>       functionCall("length")
        case _: Flatten =>      functionCall("flatten")
        case _: SelectFirst =>  functionCall("select_first")
        case _: SelectAll =>    functionCall("select_all")
        case _: Defined =>      functionCall("defined")
        case _: Floor =>        functionCall("floor")
        case _: Ceil =>         functionCall("ceil")
        case _: Round =>        functionCall("round")
      }
    }
  }

  implicit val oneOrTwoParamFunctionCallElementWriter: WdlWriter[OneOrTwoParamFunctionCallElement] = new WdlWriter[OneOrTwoParamFunctionCallElement] {
    def toWdl(a: OneOrTwoParamFunctionCallElement): String = {
      (a, a.secondParam) match {
        case (_: Size, Some(unit)) => s"size(${a.firstParam.toWdl}, ${unit.toWdl})"
        case (_: Size, None) => s"size(${a.firstParam.toWdl})"
        case (_: Basename, Some(suffix)) => s"basename(${a.firstParam.toWdl}, ${suffix.toWdl})"
        case (_: Basename, None) => s"basename(${a.firstParam.toWdl})"
      }
    }
  }

  implicit val twoParamFunctionCallElementWriter: WdlWriter[TwoParamFunctionCallElement] = new WdlWriter[TwoParamFunctionCallElement] {
    def toWdl(a: TwoParamFunctionCallElement): String = {
      def functionCall(name: String) = s"$name(${a.arg1}, ${a.arg2})"

      a match {
        case _: Zip => functionCall("zip")
        case _: Cross => functionCall("cross")
        case _: Prefix => functionCall("prefix")
      }
    }
  }

  implicit val fileElementWriter: WdlWriter[FileElement] = new WdlWriter[FileElement] {
    def toWdl(a: FileElement) = {
      a.workflows.map(_.toWdl).mkString("\n") +
      "\n" +
      a.tasks.map(_.toWdl).mkString("\n")
    }
  }

  implicit val kvPairWriter: WdlWriter[KvPair] = new WdlWriter[KvPair] {
    def toWdl(a: KvPair): String = s"${a.key} = ${a.value.toWdl}"
  }

  implicit val primitiveLiteralExpressionElementWriter: WdlWriter[PrimitiveLiteralExpressionElement] = new WdlWriter[PrimitiveLiteralExpressionElement] {
    def toWdl(a: PrimitiveLiteralExpressionElement) = a.value match {
      case a: WomBoolean => a.value.toString
      case _: WomEnumerationValue => ???
      case _: WomFile => ???
      case _: WomFloat => ???
      case a: WomInteger => a.value.toString
      case _: WomLong => ???
      case a: WomString => a.value
    }
  }
}
