package wdl.draft3.transforms.ast2wdl

import simulacrum.typeclass
import wdl.model.draft3.elements.ExpressionElement._
import wdl.model.draft3.elements._
import wom.types._
import wom.values.{WomBoolean, WomEnumerationValue, WomFile, WomFloat, WomInteger, WomLong, WomString}

import scala.language.implicitConversions

@typeclass
trait WdlWriter[A] {
  def toWdl(a: A): String
}

object WdlWriter {

  // Auto-generated by simulacrum
  import WdlWriter.ops._

  implicit val ifWriter: WdlWriter[IfElement] = new WdlWriter[IfElement] {
    def toWdl(a: IfElement) = {
      s"""if (${a.conditionExpression.toWdl}) {
         |  ${a.graphElements.map(_.toWdl).mkString("\n")}
         |}
       """.stripMargin
    }
  }

  implicit val expressionWriter: WdlWriter[ExpressionElement] = new WdlWriter[ExpressionElement] {
    def toWdl(a: ExpressionElement) = a match {
      case a: PrimitiveLiteralExpressionElement => a.toWdl
      case _: StringExpression => ???
      case a: StringLiteral => a.value
      case _: ObjectLiteral => ???
      case _: ArrayLiteral => ???
      case _: MapLiteral => ???
      case _: PairLiteral => ???
      case _: UnaryOperation => ???
      case a: BinaryOperation => a.toWdl
      case _: TernaryIf => ???
      case _: FunctionCallElement => ???
      case _: IdentifierLookup => ???
      case _: IdentifierMemberAccess => ???
      case _: ExpressionMemberAccess => ???
      case _: IndexAccess => ???
    }
  }

  implicit val binaryOperationWriter: WdlWriter[BinaryOperation] = new WdlWriter[BinaryOperation] {
    def toWdl(a: BinaryOperation) = {
      def sandwich(opString: String) = s"${a.left.toWdl} $opString ${a.right.toWdl}"

      a match {
        case _: LogicalOr           => sandwich("||")
        case _: LogicalAnd          => sandwich("&&")
        case _: Equals              => sandwich("==")
        case _: NotEquals           => sandwich("!=")
        case _: LessThan            => sandwich("< ")
        case _: LessThanOrEquals    => sandwich("<=")
        case _: GreaterThan         => sandwich("> ")
        case _: GreaterThanOrEquals => sandwich(">=")
        case _: Add                 => sandwich("+")
        case _: Subtract            => sandwich("-")
        case _: Multiply            => sandwich("*")
        case _: Divide              => sandwich("/")
        case _: Remainder           => sandwich("%")
      }
    }
  }

  implicit val graphElementWriter: WdlWriter[WorkflowGraphElement] = new WdlWriter[WorkflowGraphElement] {
    def toWdl(a: WorkflowGraphElement) = a match {
      case _: CallElement => ???
      case a: IntermediateValueDeclarationElement => s"${a.typeElement.toWdl} ${a.name} = ${a.expression.toWdl}"
      case _: OutputDeclarationElement => ???
      case _: InputDeclarationElement => ???
      case a: IfElement => a.toWdl
      case _: ScatterElement => ???
    }
  }

  implicit val typeElementWriter: WdlWriter[TypeElement] = new WdlWriter[TypeElement] {
    def toWdl(a: TypeElement) = a match {
      case a: PrimitiveTypeElement => a.primitiveType.toWdl
      case _: ArrayTypeElement => ???
      case _: MapTypeElement => ???
      case _: OptionalTypeElement => ???
      case _: NonEmptyTypeElement => ???
      case _: PairTypeElement => ???
      case _: ObjectTypeElement.type => ???
      case _: TypeAliasElement => ???
    }
  }

  implicit val primitiveTypeElementWriter: WdlWriter[WomPrimitiveType] = new WdlWriter[WomPrimitiveType] {
    def toWdl(a: WomPrimitiveType) = a.toDisplayString
  }

  implicit val primitiveLiteralExpressionElementWriter: WdlWriter[PrimitiveLiteralExpressionElement] = new WdlWriter[PrimitiveLiteralExpressionElement] {
    def toWdl(a: PrimitiveLiteralExpressionElement) = a.value match {
      case a: WomBoolean => a.value.toString
      case _: WomEnumerationValue => ???
      case _: WomFile => ???
      case _: WomFloat => ???
      case a: WomInteger => a.value.toString
      case _: WomLong => ???
      case a: WomString => a.value
    }
  }
}
